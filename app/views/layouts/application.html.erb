<!DOCTYPE html>
<html>
  <head>
    <title><%= content_for(:title) || "Triangle Tots" %></title>
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="application-name" content="Triangle Tots">
    <meta name="mobile-web-app-capable" content="yes">
    <%= csrf_meta_tags %>
    <%= csp_meta_tag %>

    <%= yield :head %>

    <%# Enable PWA manifest for installable apps (make sure to enable in config/routes.rb too!) %>
    <%#= tag.link rel: "manifest", href: pwa_manifest_path(format: :json) %>

    <link rel="icon" href="/icon.png" type="image/png">
    <link rel="icon" href="/icon.svg" type="image/svg+xml">
    <link rel="apple-touch-icon" href="/icon.png">

    <%# Includes all stylesheet files in app/assets/stylesheets %>
    <%= stylesheet_link_tag :app, "data-turbo-track": "reload" %>
    <%= stylesheet_link_tag "tailwind", "data-turbo-track": "reload" %>

    <script>
      // Location management functions
      const LocationManager = {
        STORAGE_KEY: 'triangleTots_homeLocation',

        // Check if location exists in localStorage
        hasLocation() {
          return localStorage.getItem(this.STORAGE_KEY) !== null;
        },

        // Get location from localStorage
        getLocation() {
          const data = localStorage.getItem(this.STORAGE_KEY);
          return data ? JSON.parse(data) : null;
        },

        // Save location to localStorage
        saveLocation(latitude, longitude) {
          const data = { latitude, longitude };
          localStorage.setItem(this.STORAGE_KEY, JSON.stringify(data));
        },

        // Clear location from localStorage
        clearLocation() {
          localStorage.removeItem(this.STORAGE_KEY);
        },

        // Request geolocation from browser
        requestGeolocation() {
          if (!navigator.geolocation) {
            alert('Geolocation is not supported by your browser.');
            return;
          }

          navigator.geolocation.getCurrentPosition(
            (position) => {
              const { latitude, longitude } = position.coords;
              this.saveLocation(latitude, longitude);
              this.reloadWithLocation();
            },
            (error) => {
              let errorMsg = 'Unable to get your location. ';
              if (error.code === error.PERMISSION_DENIED) {
                errorMsg += 'Please enable location access in your browser settings and try again.';
              } else if (error.code === error.POSITION_UNAVAILABLE) {
                errorMsg += 'Location information is unavailable.';
              } else if (error.code === error.TIMEOUT) {
                errorMsg += 'The request to get your location timed out.';
              } else {
                errorMsg += 'An unknown error occurred.';
              }
              alert(errorMsg);
            },
            {
              enableHighAccuracy: false,
              timeout: 10000,
              maximumAge: 300000 // 5 minutes
            }
          );
        },

        // Reload page with location parameters
        reloadWithLocation() {
          const location = this.getLocation();
          if (location) {
            const url = new URL(window.location.href);
            url.searchParams.set('home_lat', location.latitude);
            url.searchParams.set('home_lng', location.longitude);
            window.location.href = url.toString();
          }
        },

        // Initialize on page load
        init() {
          // Check if location exists
          if (!this.hasLocation()) {
            // No location stored, automatically request it
            this.requestGeolocation();
          } else {
            // Location exists, add it to current URL if not already present
            const urlParams = new URLSearchParams(window.location.search);
            if (!urlParams.has('home_lat') || !urlParams.has('home_lng')) {
              this.reloadWithLocation();
            }
          }
        }
      };

      // Initialize when DOM is ready
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => LocationManager.init());
      } else {
        LocationManager.init();
      }

      // Make LocationManager available globally for "Change Location" link
      window.LocationManager = LocationManager;

      // ActivityInteractions: Manages user ratings and activity completions in localStorage
      const ActivityInteractions = {
        STORAGE_KEY: 'triangleTots_activityInteractions',

        // Initialize storage structure
        getStorage() {
          const data = localStorage.getItem(this.STORAGE_KEY);
          if (!data) {
            return { version: "1.0", interactions: {} };
          }
          try {
            return JSON.parse(data);
          } catch (e) {
            console.error('Failed to parse interactions:', e);
            return { version: "1.0", interactions: {} };
          }
        },

        saveStorage(data) {
          localStorage.setItem(this.STORAGE_KEY, JSON.stringify(data));
        },

        // Rate an activity (1 = thumbs up, -1 = thumbs down)
        rate(activityId, rating, reloadPage = false) {
          const storage = this.getStorage();

          if (!storage.interactions[activityId]) {
            storage.interactions[activityId] = {
              rating: null,
              completions: [],
              lastCompleted: null,
              updatedAt: null
            };
          }

          storage.interactions[activityId].rating = rating;
          storage.interactions[activityId].updatedAt = new Date().toISOString();

          this.saveStorage(storage);

          if (reloadPage) {
            this.reloadWithInteractions();
          } else {
            this.updateButtonStates();
          }
        },

        // Mark activity as done
        markDone(activityId, reloadPage = false) {
          const storage = this.getStorage();
          const now = new Date().toISOString();

          if (!storage.interactions[activityId]) {
            storage.interactions[activityId] = {
              rating: null,
              completions: [],
              lastCompleted: null,
              updatedAt: null
            };
          }

          storage.interactions[activityId].completions.push(now);
          storage.interactions[activityId].lastCompleted = now;
          storage.interactions[activityId].updatedAt = now;

          this.saveStorage(storage);

          if (reloadPage) {
            // Redirect to Now feed
            const urlParams = new URLSearchParams(window.location.search);
            urlParams.set('view', 'now');
            window.location.href = '/activities?' + urlParams.toString();
          } else {
            this.reloadWithInteractions();
          }
        },

        // Reload page with interactions parameter
        reloadWithInteractions() {
          const storage = this.getStorage();
          const urlParams = new URLSearchParams(window.location.search);
          urlParams.set('interactions', JSON.stringify(storage.interactions));
          window.location.href = '/activities?' + urlParams.toString();
        },

        // Update button visual states without reload
        updateButtonStates() {
          const storage = this.getStorage();

          document.querySelectorAll('[data-activity-id]').forEach(button => {
            const activityId = button.dataset.activityId;
            const interaction = storage.interactions[activityId];
            const interactionType = button.dataset.interactionType;

            if (interaction) {
              // Update thumbs up/down states
              if (interactionType === 'thumbs-up') {
                if (interaction.rating === 1) {
                  button.classList.add('bg-green-100', 'border-green-500');
                  button.classList.remove('border-gray-300');
                } else {
                  button.classList.remove('bg-green-100', 'border-green-500');
                  button.classList.add('border-gray-300');
                }
              }

              if (interactionType === 'thumbs-down') {
                if (interaction.rating === -1) {
                  button.classList.add('bg-red-100', 'border-red-500');
                  button.classList.remove('border-gray-300');
                } else {
                  button.classList.remove('bg-red-100', 'border-red-500');
                  button.classList.add('border-gray-300');
                }
              }

              if (interactionType === 'mark-done') {
                if (interaction.lastCompleted) {
                  button.classList.add('bg-blue-100', 'border-blue-500');
                  button.classList.remove('border-gray-300');
                } else {
                  button.classList.remove('bg-blue-100', 'border-blue-500');
                  button.classList.add('border-gray-300');
                }
              }
            }
          });
        },

        // Get interactions for a specific activity
        getInteraction(activityId) {
          const storage = this.getStorage();
          return storage.interactions[activityId.toString()] || null;
        },

        // Get all interactions
        getAllInteractions() {
          return this.getStorage().interactions;
        },

        // Initialize button states on page load
        init() {
          // Add interactions to page load if they exist
          const storage = this.getStorage();
          if (Object.keys(storage.interactions).length > 0) {
            // Add interactions to URL if not already present
            const urlParams = new URLSearchParams(window.location.search);
            if (!urlParams.has('interactions')) {
              urlParams.set('interactions', JSON.stringify(storage.interactions));
              // Update URL without reload using pushState
              const newUrl = window.location.pathname + '?' + urlParams.toString();
              window.history.replaceState({}, '', newUrl);
            }
          }

          // Update button states
          this.updateButtonStates();
        }
      };

      // Initialize when DOM is ready
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => ActivityInteractions.init());
      } else {
        ActivityInteractions.init();
      }

      // Make ActivityInteractions available globally
      window.ActivityInteractions = ActivityInteractions;
    </script>
  </head>

  <body class="min-h-screen" style="background-color: #FAF9F4;">
    <%= yield %>
  </body>
</html>
